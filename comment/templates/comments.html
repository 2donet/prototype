{% load humanize %}
{% load static %}
{% load comment_tags %}

<!-- Admin Comment Status Filter - Only shown ONCE at top level -->
{% if user.is_staff or user.is_superuser or can_moderate %}
{% if not is_nested_include %}
<div id="admin-comment-filters" style="margin-bottom: 15px; padding: 12px; background: var(--bg-color2); border-radius: 6px; border-left: 3px solid var(--information);">
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
        <span style="color: var(--text); font-weight: 500; display: flex; align-items: center;">
            <i class="material-icons" style="color: var(--information); margin-right: 8px; font-size: 18px;">filter_list</i>
            Admin Filters
        </span>
        <span id="filter-count" style="color: var(--text2ndary); font-size: 12px;"></span>
    </div>
    
    <div style="display: flex; flex-wrap: wrap; gap: 12px; font-size: 13px; margin-bottom: 15px;">
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="APPROVED" checked />
            <span style="color: var(--confirm); margin-left: 6px;">‚úì Approved</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="PENDING" checked />
            <span style="color: var(--warning); margin-left: 6px;">‚è≥ Pending</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="REJECTED" />
            <span style="color: var(--danger); margin-left: 6px;">‚ùå Rejected</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="FLAGGED" />
            <span style="color: var(--risk); margin-left: 6px;">üö© Flagged</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="CONTENT_REMOVED" />
            <span style="color: var(--status-purple); margin-left: 6px;">üóëÔ∏è Content Removed</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="AUTHOR_REMOVED" />
            <span style="color: var(--status-pink); margin-left: 6px;">üë§ Author Hidden</span>
        </label>
        
        <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" class="filled-in comment-filter-checkbox" data-status="THREAD_DELETED" />
            <span style="color: var(--highlightdark); margin-left: 6px;">üóëÔ∏è Deleted</span>
        </label>
    </div>
    
    <!-- Buttons section -->
    <div style="display: flex; gap: 10px; align-items: center;">
        <button type="button" class="btn-small waves-effect waves-light" id="apply-filters-btn" 
                style="background: var(--information); color: var(--text);">
            <i class="material-icons left">filter_alt</i>Apply Filters
        </button>
        <button type="button" class="btn-small waves-effect waves-light" id="clear-filters-btn" 
                style="background: var(--danger); color: var(--text);">
            <i class="material-icons left">clear</i>Clear All
        </button>
    </div>
</div>

<!-- Loading indicator -->
<div id="comments-loading" style="display: none; text-align: center; padding: 20px; color: var(--text2ndary);">
    <div class="preloader-wrapper small active">
        <div class="spinner-layer spinner-blue-only">
            <div class="circle-clipper left">
                <div class="circle"></div>
            </div>
            <div class="gap-patch">
                <div class="circle"></div>
            </div>
            <div class="circle-clipper right">
                <div class="circle"></div>
            </div>
        </div>
    </div>
    <p style="margin-top: 10px;">Loading comments...</p>
</div>
{% endif %}
{% endif %}

<!-- Comments container - ID only at top level -->
<div {% if not is_nested_include %}id="comments-container"{% endif %}>
{% for comment in comments %}
<!-- Only show approved comments to regular users, all comments to moderators -->
{% if comment.status == 'APPROVED' or user.is_staff or comment|can_moderate_comment:user %}
<div class="comment" data-comment-id="{{ comment.id }}" {% if comment.user_vote%}data-user-vote="{{ comment.user_vote }}" {% endif %}>
    {% comment_avatar comment.user %}

    <span>
        <i title="{{ comment.pub_date }}" style="float: right;">{{ comment.pub_date|naturaltime }}</i>

        <!-- Handle different author display statuses -->
        {% if comment.status == 'AUTHOR_REMOVED' or comment.status == 'AUTHOR_AND_CONTENT_REMOVED' %}
            <span style="color: #666; font-style: italic;">[Hidden]</span>
        {% elif comment.user %}
            <a href="/u/{{comment.user.id}}"> {{ comment.user }} </a>
        {% else %}
            <span>Anonymous</span>
        {% endif %}

        <!-- Show moderation status to moderators -->
        {% if user.is_staff or comment|can_moderate_comment:user %}
            {% if comment.status != 'APPROVED' %}
                <span class="moderation-status" style="background: #ff6b6b; color: white; padding: 2px 6px; border-radius: 10px; font-size: 11px;">
                    {{ comment.get_status_display }}
                </span>
            {% endif %}
            
            <!-- Show history indicator if comment has moderation history -->
            {% if comment.has_moderation_history %}
                <span class="history-indicator" style="background: #2196f3; color: white; padding: 2px 6px; border-radius: 10px; font-size: 11px; margin-left: 5px;">
                    {{ comment.change_log.count }} change{{ comment.change_log.count|pluralize }}
                </span>
            {% endif %}
        {% endif %}

        <div class="comment-actions">
            <!-- Vote buttons with improved UI -->
            <div class="vote-container">
                <a href="#" class="upvote-btn tooltipped" data-position="top" data-tooltip="Upvote">
                    <i>üëç</i>
                </a>
                <span class="score">{{ comment.score }}</span>
                <a href="#" class="downvote-btn tooltipped" data-position="top" data-tooltip="Downvote">
                    <i>üëé</i>
                </a>
            </div>

            <!-- Comment menu -->
            <a class='dropdown-trigger btn-flat' href='#' data-target='actions-{{comment.id}}'>
                <img src="{% static 'icons/menu.svg' %}" alt="actions">
            </a>

            <!-- Dropdown Structure -->
            <ul id='actions-{{comment.id}}' class='dropdown-content'>
                {% if request.user.is_staff %}
                <li>
                    <a href="/admin/portal/project/{{ project.id }}/change/">[ ADMIN ]</a>
                </li>
                {% endif %}
                
                <!-- History link for moderators -->
                {% if user|can_view_comment_history:comment %}
                    <li>
                        <a href="{% url 'comments:comment_history' comment.id %}">
                            üìú View History
                            {% if comment|change_count > 0 %}
                                ({{ comment|change_count }})
                            {% endif %}
                        </a>
                    </li>
                {% endif %}
                
                {% if request.user == comment.user or request.user.is_staff %}
                <li><a href="{% url 'comments:edit_comment' comment.id %}">Edit</a></li>
                {% endif %}
                <li>
                    <a href="/messages/{{ comment.user.username }}/">‚úâÔ∏è Message</a>
                </li>
                <li>
                    <a href="{% url 'comments:report_comment' comment.id %}">
                        üö© Report
                    </a>
                </li>
            </ul>
        </div>
    </span>

    <p>
        <!-- Handle different content display statuses -->
        {% if comment.status == 'CONTENT_REMOVED' or comment.status == 'AUTHOR_AND_CONTENT_REMOVED' %}
            <em style="color: #666;">[Content removed by moderation]</em>
            
            <!-- Show original content to admins -->
            {% if user.is_superuser or user.is_staff %}
                <details style="margin-top: 5px;">
                    <summary style="cursor: pointer; color: #2196f3; font-size: 12px;">Show Original (Admin Only)</summary>
                    <div style="padding: 8px; margin-top: 3px; border-radius: 3px; font-size: 14px;">
                        {{ comment.get_original_content|linebreaks }}
                    </div>
                </details>
            {% endif %}
        {% elif comment.status == 'THREAD_DELETED' or comment.status == 'REPLY_TO_DELETED' %}
            <em style="color: #666;">[Comment deleted]</em>
            
            <!-- Show original content to admins -->
            {% if user.is_superuser or user.is_staff %}
                <details style="margin-top: 5px;">
                    <summary style="cursor: pointer; color: #2196f3; font-size: 12px;">Show Original (Admin Only)</summary>
                    <div style="padding: 8px; margin-top: 3px; border-radius: 3px; font-size: 14px;">
                        {{ comment.get_original_content|linebreaks }}
                    </div>
                </details>
            {% endif %}
        {% else %}
            {{ comment.content | linebreaks }}
        {% endif %}
        
        <!-- Show edit indicator -->
        {% if comment.is_edited %}
            <small style="color: #666; font-style: italic;">
                (edited)
                {% if user.is_staff or comment|can_moderate_comment:user %}
                    - <a href="{% url 'comments:comment_history' comment.id %}" style="color: #2196f3;">view history</a>
                {% endif %}
            </small>
        {% endif %}
    </p>

    <!-- Only show interactive elements for non-deleted comments -->
    {% if comment.status not in 'THREAD_DELETED,REPLY_TO_DELETED' %}
        <!-- Link to single comment view -->
        <a href="{% url 'comments:single_comment' comment.id %}">Permalink</a>

        <span></span> {{ comment.total_replies }} replies

        {% if comment.total_replies > 0 %}
            <button class="view-replies-btn" data-comment-id="{{ comment.id }}">View Replies</button>
        {% endif %}

        <button class="reply-btn" data-comment-id="{{ comment.id }}"
            data-controls="reply-form-{{comment.id}}">Reply</button>
            
        
        <div class="replies-container" data-comment-id="{{ comment.id }}" style="display: none;">
            {% include "comments.html" with comments=comment.replies.all is_nested_include=True %}
        </div>
    {% endif %}

</div>
{% endif %}
{% endfor %}
</div>

<!-- Context data and JavaScript - ONLY AT TOP LEVEL -->
{% if user.is_staff or user.is_superuser or can_moderate %}
{% if not is_nested_include %}
<script type="application/json" id="comment-context-data">
{
    "object_type": "{% if project %}project{% elif task %}task{% elif need %}need{% elif problem %}problem{% else %}unknown{% endif %}",
    "object_id": {% if project %}{{ project.id }}{% elif task %}{{ task.id }}{% elif need %}{{ need.id }}{% elif problem %}{{ problem.id }}{% else %}null{% endif %},
    "can_moderate": {% if can_moderate %}true{% else %}false{% endif %}
}
</script>

<script>
// Define helper functions first, outside of any other function
function getContextData() {
    try {
        const contextScript = document.getElementById('comment-context-data');
        if (contextScript) {
            const data = JSON.parse(contextScript.textContent);
            return data;
        } else {
            return null;
        }
    } catch (e) {
        console.warn('Could not parse context data:', e);
        return null;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    
    // Debug: Check if we can find the filter checkboxes
    const filterCheckboxes = document.querySelectorAll('.comment-filter-checkbox');

    
    // More permissive check - initialize if we have filter checkboxes
    if (filterCheckboxes.length > 0) {
        
        initializeAdminCommentFiltering();
    } else {
    }
});

function initializeAdminCommentFiltering() {
    
    const filterCheckboxes = document.querySelectorAll('.comment-filter-checkbox');
    const commentsContainer = document.getElementById('comments-container');
    const loadingIndicator = document.getElementById('comments-loading');
    const filterCount = document.getElementById('filter-count');
    const applyFiltersBtn = document.getElementById('apply-filters-btn');
    const clearFiltersBtn = document.getElementById('clear-filters-btn');
    let filtersChanged = false;
    
    // Get context from current page
    const currentContext = getCurrentContext();
    
    // Add change listeners to checkboxes (just for visual feedback, not auto-apply)
    filterCheckboxes.forEach((checkbox, index) => {
        checkbox.addEventListener('change', function() {
            filtersChanged = true;
            updateApplyButtonState();
        });
    });
    
    // Add click listener to Apply Filters button
    if (applyFiltersBtn) {
        applyFiltersBtn.addEventListener('click', function() {
            fetchFilteredComments();
            filtersChanged = false;
            updateApplyButtonState();
        });
    }
    
    // Add click listener to Clear Filters button
    if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener('click', function() {
            filterCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            filtersChanged = true;
            updateApplyButtonState();
            
            // Auto-apply after clearing
            setTimeout(() => {
                fetchFilteredComments();
                filtersChanged = false;
                updateApplyButtonState();
            }, 100);
        });
    }
    
    // Load saved filter state from localStorage
    loadFilterState();
    
    function updateApplyButtonState() {
        if (applyFiltersBtn) {
            if (filtersChanged) {
                applyFiltersBtn.style.background = 'var(--warning)';
                applyFiltersBtn.innerHTML = '<i class="material-icons left">filter_alt</i>Apply Changes';
            } else {
                applyFiltersBtn.style.background = 'var(--information)';
                applyFiltersBtn.innerHTML = '<i class="material-icons left">filter_alt</i>Apply Filters';
            }
        }
    }
    
    function getCurrentContext() {
        const contextData = getContextData();
        if (contextData && contextData.object_type && contextData.object_id) {
            return {
                object_type: contextData.object_type,
                object_id: contextData.object_id
            };
        }
        
        // Fallback to URL parsing
        const pathParts = window.location.pathname.split('/');
        
        // Handle direct project ID pattern: /123/
        if (pathParts.length >= 2 && pathParts[1] && !isNaN(pathParts[1])) {
            return {
                object_type: 'project',
                object_id: parseInt(pathParts[1])
            };
        }
        
        return { object_type: 'project', object_id: null };
    }
    
    function getSelectedStatuses() {
        const selected = Array.from(filterCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.dataset.status);
        return selected;
    }
    
    function saveFilterState() {
        const selectedStatuses = getSelectedStatuses();
        localStorage.setItem('adminCommentFilters', JSON.stringify(selectedStatuses));
    }
    
    function loadFilterState() {
        try {
            const saved = localStorage.getItem('adminCommentFilters');
            if (saved) {
                const savedStatuses = JSON.parse(saved);
                filterCheckboxes.forEach(checkbox => {
                    checkbox.checked = savedStatuses.includes(checkbox.dataset.status);
                });
            } else {
                // Set default filters (APPROVED and PENDING)
                filterCheckboxes.forEach(checkbox => {
                    if (checkbox.dataset.status === 'APPROVED' || checkbox.dataset.status === 'PENDING') {
                        checkbox.checked = true;
                    }
                });
            }
            filtersChanged = false;
            updateApplyButtonState();
        } catch (e) {
            console.warn('Could not load filter state:', e);
        }
    }
    
    function showLoading() {
        if (loadingIndicator) loadingIndicator.style.display = 'block';
        if (commentsContainer) commentsContainer.style.opacity = '0.5';
        if (applyFiltersBtn) {
            applyFiltersBtn.disabled = true;
            applyFiltersBtn.innerHTML = '<i class="material-icons left">hourglass_empty</i>Loading...';
        }
    }
    
    function hideLoading() {
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        if (commentsContainer) commentsContainer.style.opacity = '1';
        if (applyFiltersBtn) {
            applyFiltersBtn.disabled = false;
            updateApplyButtonState();
        }
    }
    
    function fetchFilteredComments() {
        
        const selectedStatuses = getSelectedStatuses();
        
        if (selectedStatuses.length === 0) {
            if (commentsContainer) {
                commentsContainer.innerHTML = '<p style="color: var(--text2ndary); text-align: center; padding: 20px;">No filters selected - check some boxes and click Apply</p>';
            }
            if (filterCount) filterCount.textContent = 'No filters selected';
            saveFilterState();
            return;
        }
        
        showLoading();
        saveFilterState();
        
        const requestData = {
            statuses: selectedStatuses,
            ...currentContext
        };
        
        
        fetch('/comments/ajax/filtered/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken(),
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            return response.json();
        })
        .then(data => {
            hideLoading();
            
            if (data.success) {
                if (commentsContainer) {
                    commentsContainer.innerHTML = data.comments_html;
                }
                if (filterCount) {
                    filterCount.textContent = `${data.filtered_count} of ${data.total_count} comments`;
                }
                
                // Reinitialize MaterializeCSS components
                if (typeof M !== 'undefined') {
                    M.Dropdown.init(document.querySelectorAll('.dropdown-trigger'), {
                        constrainWidth: false,
                        coverTrigger: false,
                        alignment: 'right'
                    });
                    M.Tooltip.init(document.querySelectorAll('.tooltipped'));
                }
                
                // Reinitialize comment event listeners
                if (typeof addCommentEventListeners === 'function') {
                    document.querySelectorAll('.comment').forEach(comment => {
                        addCommentEventListeners(comment);
                    });
                }
                
            } else {
                console.error('API returned error:', data.error);
                if (commentsContainer) {
                    commentsContainer.innerHTML = `<p style="color: var(--danger); text-align: center; padding: 20px;">Error: ${data.error}</p>`;
                }
                if (filterCount) filterCount.textContent = 'Error loading';
            }
        })
        .catch(error => {
            console.error('AJAX error:', error);
            hideLoading();
            if (commentsContainer) {
                commentsContainer.innerHTML = '<p style="color: var(--danger); text-align: center; padding: 20px;">Failed to load comments</p>';
            }
            if (filterCount) filterCount.textContent = 'Load failed';
        });
    }
    
    function getCSRFToken() {
        const token = document.querySelector('[name=csrfmiddlewaretoken]') || 
                     document.querySelector('input[name="csrfmiddlewaretoken"]') ||
                     document.querySelector('meta[name="csrf-token"]');
        const tokenValue = token ? token.value || token.content : '';
        return tokenValue;
    }
    
    // Initial load with current filter state
    setTimeout(() => {
        fetchFilteredComments();
        filtersChanged = false;
        updateApplyButtonState();
    }, 100);
}
</script>
{% endif %}
{% endif %}